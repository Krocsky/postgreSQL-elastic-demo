# 内部通用工具类库

## 安装

`npm install @cybereits/ccl`

## 引用

按需引用

```javascript
import { concatUrl, getParams } from '@cybereits/ccl/url'
```

或者是全部引用

```javascript
import { url } from '@cybereits/ccl'
const { concatUrl, getParams } = url
```

## 文档

### asyncQueue 异步队列管理

#### ParallelQueue 并行队列

可以通过 limit 控制任务并发数，如后面代码所示，10 个异步任务会以 并发数 5 个的形式执行。先执行 1-5 个任务，某个任务首先完成后，则继续将任务 6 加入到执行队列，依次类推，直至所有任务都成功完成。

- 参数
  - limit 并行限制
  - span 任务执行间隔
  - toleration 单个任务失败重试次数
  - onFinished 成功后的回调（不推荐使用，将在后续版本中移除）
- 方法
  - add 添加任务胶囊
  - abort 取消继续执行
  - consume 开始消费队列（类似 start），返回 Promise 对象
  - flush 清空任务队列

#### SerialQueue 串行队列

没有 limit 也就是没有并发的概念，其会按照任务 1-10 的顺序逐个进入执行队列。通过设置 abortAfterFail 为 true（默认 false），可以让队列在只有前一个任务执行成功后才会继续，否则将中断。

- 参数
  - abortAfterFail 失败后放弃执行后续的任务（默认 false）
  - toleration 单个任务失败重试次数
  - onFinished 成功后的回调（不推荐使用，将在后续版本中移除）
- 方法
  - add 添加任务胶囊
  - abort 取消继续执行
  - consume 开始消费队列（类似 start），返回 Promise 对象
  - flush 清空任务队列

#### TaskCapsule 任务胶囊

其接受一个返回 Promise 对象的函数，执行时会调用该函数。当该函数返回的 Promise resolve 时，视作执行成功；当 Promise reject 时，则视作失败。

#### 示例

```javascript
import { TaskCapsule, ParallelQueue, SerialQueue } from '@cybereits/ccl/asyncQueue'

const taskQueue = new ParallelQueue({
  // 任务并发数量
  limit: 5,
  // 任务失败后的重试次数
  // 注意一些不具有幂等性的任务不可以设置 toleration，其应显式的指定 0
  toleration: 3,
  // 任务运行间隔
  span: 300,
})

taskQueue.add(
  new TaskCapsule(
    () => new Promise((resolve) => {
      setTimeout(() => {
        console.log(`Task ${index + 1} executed!`)
        resolve()
      }, Math.random() * 100)
    }),
  ),
)

taskQueue
  .consume()
  .then(()=>{
    console.log('所有任务已经执行完毕.')
  })
  .catch((ex)=>{
    // 执行出错
  })

```

### url 处理工具

拼接 url 或者从 url 中获取 query 参数对象

```javascript
import { getParams, concatUrl } from '@cybereits/ccl/url'

concatUrl('http://localhost', { name:1 }) // http://localhost?name=1
concatUrl('http://localhost?name=1', { name:2, age:3 })  // http://localhost?name=2&age=3
getParams('http://localhost?name=marsoln&age=29') // { name:'marsoln', age:29 }
```

concatUrl 可以通过设置第三个参数 need_encode 为 true 来将参数的字符串进行 urlEncode 操作:
`concatUrl('http://localhost', { name:'小王' }, true)` 会得到 `'http://localhost?name=%E5%B0%8F%E7%8E%8B'` 的结果

### polyfill 填充物

填充物在使用时只需要引入就可以了

```javascript
import '@cybereits/ccl/polyfill'

// ...
```

填充物保证了在 ES5.1 的环境中如下几个 ES6 的扩展方法：

- Object.entries
- Object.keys
- Object.assign
- Array.prototype.fill

> 需要注意的是：为了保证正常使用 polyfill 最好在入口文件的头部引用

### validator 通用的验证函数

- chk_id 校验身份证号
- chk_mobile 校验手机号
- chk_bankno 校验银行卡号
- chk_email 校验邮箱
- chk_check_code 校验验证码格式
- chk_login_pwd 校验登录密码格式
- chk_pay_pwd 校验支付密码格式
- chk_decimal 检验传入的数字的字符串是否具有合法的小数点后的位数

### formatter 通用的格式化函数

- money 格式化金额
  - num 金额数值
  - withoutUnit 是否带单位 ¥（默认 false）
- fixZero 将指定数值转换为 2 位左补 0 的格式
  - num 数值
- time 将秒数转换成 天、小时、分、秒 的形式
  - seconds 秒数
- floor 指定小数点精度的 floor
  - number 数值
  - decimalLimit 小数点位数限制（默认 2）
- hideStr 将字符串的某一部分替换成指定的符号
  - str 原始字符串
  - len 替换的长度
  - sign 替换的符号
  - startIndex 开始的下标
- separate 按照指定长度和分隔符去分割字符串
  - str 原始的字符串
  - blockLength 每块的最大长度
  - separator 分隔符

### redisWrapper redis客户端的包裹

依赖于 node-redis，主要的作用就是在客户端调用一个指令后会将链接释放。其次就是扩展出了 `getObj` 和 `setObj` 两个方法，可以方便的存储 JSON 对象。

```javascript
import redis from 'redis'
import redisWrapper from '@cybereits/ccl/redisWrapper'

const conn = redisWrapper(redis, {
  // node-redis 的连接配置
})

conn.setObj('store-key', { name:'marsoln' }, 30000)  // 设置一个对象 30 秒后过期
conn.getObj('store-key').then((obj) => {
  console.log(JSON.stringify(obj)) // { name : 'marsoln' }
})
setTimeout(() => {
  conn.getObj('store-key').then((obj) => {
    console.log(obj) // null
  })
}, 30000)
```