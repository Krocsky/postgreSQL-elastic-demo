'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var start = Symbol('start');
var retry = Symbol('retry');
var _abort = Symbol('abort');
var finish = Symbol('finish');

var prepareToBegin = Symbol('prepareToBegin');
var execAmountChange = Symbol('execAmountChange');
var consumeValid = Symbol('consumeValid');

// #region Single Task Wrapper

var TaskCapsule = function () {
  // func must be an asynchronized function
  // if it's not
  // why you need task queue?
  function TaskCapsule(func, ctx) {
    _classCallCheck(this, TaskCapsule);

    this.exec = func;
    this.ctx = ctx;

    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.args = args;
    this[retry] = 0;
  }

  _createClass(TaskCapsule, [{
    key: 'run',
    value: function run() {
      return this.exec.apply(this.ctx || this, this.args);
    }
  }]);

  return TaskCapsule;
}();

// #endregion

// #region Task Queues

var TaskQueue = function () {
  function TaskQueue(_ref) {
    var _this = this;

    var onFinished = _ref.onFinished;

    _classCallCheck(this, TaskQueue);

    this.queue = []; // task queue
    this[_abort] = false; // is abort
    this.done = false; // has done
    this.onHandle = false; // is handlering
    this.total = 0;
    this.succ = 0;
    this.fail = 0;
    this.onExecAmount = 0;
    this.onFinished = onFinished;
    this.__resolve = null;
    this.__reject = null;
    this.__promise = new Promise(function (resolve, reject) {
      _this.__resolve = resolve;
      _this.__reject = reject;
    });
  }

  _createClass(TaskQueue, [{
    key: 'add',
    value: function add(task) {
      if (!(task instanceof TaskCapsule)) {
        throw new TypeError('Task must be an instance of type - <TaskCapsule>.');
      }
      this.queue.push(task);
    }
  }, {
    key: prepareToBegin,
    value: function value() {
      if (!this.onHandle) {
        this[_abort] = false;
        this.done = false;
        this.onHandle = true;
        this.total = this.queue.length;
        this.succ = 0;
        this.fail = 0;
        this.onExecAmount = 0;
        return true;
      }
      return false;
    }
  }, {
    key: execAmountChange,
    value: function value(num) {
      this.onExecAmount += num;
      if (this.onExecAmount <= 0 && this.queue.length === 0) {
        this[finish](true);
      }
    }
  }, {
    key: consumeValid,
    value: function value() {
      if (this.done) {
        if (this.onExecAmount > 0) {
          console.info('Called consume after the tasks were handled. Thats\'s all right.');
        }
        return false;
      } else if (this[_abort]) {
        console.warn('Tasks abort.');
        this[finish](false);
        return false;
      } else if (this.queue.length === 0) {
        return false;
      } else {
        return true;
      }
    }
  }, {
    key: finish,
    value: function value(flag) {
      this.onHandle = false;
      this.done = true;
      if (flag && this.__resolve && this.succ === this.total) {
        this.__resolve.call(this);
      } else if (this.__reject) {
        this.__reject.call(this);
      }
      if (this.onFinished) {
        this.onFinished.call(this);
      }
    }
  }, {
    key: 'abort',
    value: function abort() {
      this[_abort] = true;
    }
  }, {
    key: 'flush',
    value: function flush() {
      this.queue = [];
    }
  }]);

  return TaskQueue;
}();

var ParallelQueue = function (_TaskQueue) {
  _inherits(ParallelQueue, _TaskQueue);

  function ParallelQueue(_ref2) {
    var _ref2$limit = _ref2.limit,
        limit = _ref2$limit === undefined ? 5 : _ref2$limit,
        _ref2$span = _ref2.span,
        span = _ref2$span === undefined ? 300 : _ref2$span,
        _ref2$toleration = _ref2.toleration,
        toleration = _ref2$toleration === undefined ? 3 : _ref2$toleration,
        onFinished = _ref2.onFinished;

    _classCallCheck(this, ParallelQueue);

    var _this2 = _possibleConstructorReturn(this, (ParallelQueue.__proto__ || Object.getPrototypeOf(ParallelQueue)).call(this, { onFinished: onFinished }));

    _this2.limitation = limit;
    _this2.timespan = span;
    _this2.toleration = toleration;
    return _this2;
  }

  _createClass(ParallelQueue, [{
    key: start,
    value: function value() {
      var _this3 = this;

      if (this[consumeValid]()) {
        if (this.onExecAmount < this.limitation && this.queue.length > 0) {
          var task = this.queue.shift();
          this[execAmountChange](1);
          task.run().then(function () {
            // exec success
            _this3.succ += 1;
            _this3[execAmountChange](-1);
          }).catch(function (e) {
            if (task[retry] >= _this3.toleration) {
              // retried many times still failed
              _this3.fail += 1;
            } else {
              // failed but retry it
              task[retry] += 1;
              _this3.queue.unshift(task);
            }
            _this3[execAmountChange](-1);
          });
        }
        if (this.timespan > 0) {
          setTimeout(this[start].bind(this), this.timespan);
        } else {
          this[start].call(this);
        }
      }
    }
  }, {
    key: 'consume',
    value: function consume() {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        _this4.__resolve = resolve;
        _this4.__reject = reject;
        if (_this4[prepareToBegin]()) {
          if (_this4.queue.length > 0) {
            for (var _i = 0; _i < _this4.limitation; _i += 1) {
              _this4[start]();
            }
          } else {
            _this4[execAmountChange](0);
          }
        } else {
          _this4.__reject(new Error('not able to consume'));
        }
      });
    }
  }]);

  return ParallelQueue;
}(TaskQueue);

var SerialQueue = function (_TaskQueue2) {
  _inherits(SerialQueue, _TaskQueue2);

  function SerialQueue(_ref3) {
    var _ref3$abortAfterFail = _ref3.abortAfterFail,
        abortAfterFail = _ref3$abortAfterFail === undefined ? false : _ref3$abortAfterFail,
        _ref3$toleration = _ref3.toleration,
        toleration = _ref3$toleration === undefined ? 3 : _ref3$toleration,
        onFinished = _ref3.onFinished;

    _classCallCheck(this, SerialQueue);

    var _this5 = _possibleConstructorReturn(this, (SerialQueue.__proto__ || Object.getPrototypeOf(SerialQueue)).call(this, { onFinished: onFinished }));

    _this5.abortAfterFail = abortAfterFail;
    _this5.toleration = toleration;
    return _this5;
  }

  _createClass(SerialQueue, [{
    key: start,
    value: function value() {
      var _this6 = this;

      if (this[consumeValid]()) {
        this[execAmountChange](1);
        var task = this.queue.shift();
        task.run().then(function () {
          _this6.succ += 1;
          _this6[execAmountChange](-1);
          _this6[start].call(_this6);
        }).catch(function () {
          if (task[retry] >= _this6.toleration) {
            // retried many times still failed
            _this6.fail += 1;
            if (_this6.abortAfterFail) {
              _this6[finish](false);
              return false;
            }
          } else {
            // failed but retry it
            task[retry] += 1;
            _this6.queue.unshift(task);
          }
          _this6[execAmountChange](-1);
          _this6[start].call(_this6);
        });
      }
    }
  }, {
    key: 'consume',
    value: function consume() {
      var _this7 = this;

      return new Promise(function (resolve, reject) {
        _this7.__resolve = resolve;
        _this7.__reject = reject;
        if (_this7[prepareToBegin]()) {
          if (_this7.queue.length > 0) {
            _this7[start]();
          } else {
            _this7[execAmountChange](0);
          }
        } else {
          _this7.__reject(new Error('not able to consume'));
        }
      });
    }
  }]);

  return SerialQueue;
}(TaskQueue);

// #endregion

exports.TaskCapsule = TaskCapsule;
exports.ParallelQueue = ParallelQueue;
exports.SerialQueue = SerialQueue;